syntax = "proto3";

message HandshakeFromHost {
	// client should sign this data with key and return the signature in HandshakeFromClient
	bytes tosign = 1;
}

message HandshakeFromClient {
	// client signature
	bytes signature = 1;
}

message Command {

}

message Response {

}

message Sequence {
	// a sequence name used to identify it later
	string name = 1;
	repeated Task tasks = 2;
	repeated Trigger triggers = 3;
}

message Trigger {
	// a client-assigned trigger id (unique to the current Sequence)
	uint64 id = 1;
	// a delay (in milliseconds) that the trigger should fire after the associated event
	// a delay of zero will be truly instantaneous
	uint64 delay = 2;
}

message Task {
	// a client-assigned task id (unique to the current Sequence)
	uint32 id = 1;
	// the id of the trigger that requests this task
	uint64 trigger = 2;

	oneof task {
		TaskExec exec = 10;
		TaskMatchWindow match_window = 11;
		TaskPlaceContent place_content = 12;
		TaskShowText show_text = 13;
	}
}

message TaskExec {
	string program = 1;
	repeated string args = 2;
}

message TaskShowText {
	// a client-assigned content id (unique to the current Sequence)
	uint32 content_id = 1;

	string text = 2;
}

message TaskMatchWindow {
	// a client-assigned content id (unique to the current Sequence)
	// the matched window will be assigned to this id
	uint32 content_id = 1;

	// should this task match against windows that opened before this task was triggered?
	// or should it wait for a new window to open?
	bool match_history = 2;

	// regexes to use to match against window properties
	string title = 3;
	string class = 4;
	string role = 5;

	// some windows do add a process id property (but this is not guaranteed)
	uint32 pid = 6; // note that not all applications support this
}

message TaskPlaceContent {
	// the id of the content to place
	uint32 content_id = 1;

	oneof location {
		LocationSplit split = 2;
	}
}

enum Side {
	TOP = 0;
	BOTTOM = 1;
	LEFT = 2;
	RIGHT = 3;
}

message LocationSplit {
	Side side = 1;
	float ratio = 2;
}